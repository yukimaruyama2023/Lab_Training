# 2-4
#### 実行結果
```
p[0] = f4, p[1] = f3, p[2] = f2, p[3] = f1
```
#### 理由
変換指定子%hhxは、長さ修飾子hhに、unsigned char変換を表すxがついたものである。したがって、七行目の各アドレスに格納されている
変数の値がunsigned charとして表示される。xはint型であるので4バイトのメモリを消費するが、xを格納しているpはchar型のポインタとして宣言しているので
*p, *(p + 1), *(p + 2), *(p + 3)はそれぞれメモリの1バイト分に格納されている値となる。そして、この実行結果からバイトオーダーはリトルエンディアン
であるとわかる。

# 2-5
#### 実行結果
```
p[0] = -12, p[1] = -13, p[2] = -14, p[3] = -15
```
#### 理由
六行目の変換指定子は%dであるので、引数がint型の4バイトより短いときには符号拡張される。p[0]には0xf4、二進数に直すと1111 0100が格納されている。これを32bitに符号拡張すると1111 1111 1111 1111 1111 1111 1111 0100となる。符号付き整数ではこれは-12を表すので、p[0] = -12と表示された。p[1]~p[3]についても同じである。

# 2-6
#### 実行結果
```shell
x: 0x102764000
y: 0x102764004
```
#### 理由
yはint型であるのでアライメント規約により、4の倍数のアドレスから始まるメモリから始まる。したがって、0x102764000の一バイトにcharが格納され、3バイトあいてからyが格納される。

# 2-7
#### 実行結果
```shell
&p = 0x100844028
 p = 0x100844000 | &a[0] = 0x100844000
*p =           5 | a[5] =           5 |*(a+5) =           5
 p = 0x100844014 |&a[5] = 0x100844014 | (a+5) = 0x100844014
```

#### &a[3]
0x102f34000c

#### a, pをshortに変えると
short intは一つの変数に2バイトのメモリを消費する。実行結果は次のようになった。
```shell
&p = 0x10262c018
 p = 0x10262c000 | &a[0] = 0x10262c000
*p =           5 | a[5] =           5 |*(a+5) =           5
 p = 0x10262c00a |&a[5] = 0x10262c00a | (a+5) = 0x10262c00a
```
&a[0]をvとすると&a[5]は10進数でv+10となる。


#### a[10]に値を書き込むとコンパイル時に
```
array index 10 is past the end of the array (which contains 10 elements) [-Warray-bounds]
とwarningが出る。
```
#### sizeof(a) / sizeof(int)　の意味
sizeof(a)は、配列aに確保されたメモリのサイズを表す。sizeof(int)は、int型の変数一つあたりに確保されるメモリのサイズを表す。配列aはint型変数を格納するので、sizeof(a) / sizeof(int)は配列の要素数を返す。

#### init_arrary()でうまくいかない理由
関数init_arrayでは配列a[]を受けとっているが、sizeof(a)は、受け取った配列のために確保されているメモリサイズではなく、配列の先頭要素を指すポインタのメモリサイズを指す。すなわちsizeof(a) == sizeof(int *)となり、実際にsizeof(a)の値は8となった。

# 2-8
#### 実行結果
```
Helso
```
#### 理由

”Hello”には、文字列Helloの格納されている先頭アドレスが格納されている。したがって、*HはHとなる。"everybody"[2]は、配列”everybody"の二つ目の要素であり、この配列には”everybody”が格納されている。したがって、"everybody"[2]はeとなる。*("welcome" + 2)において、”Hello"はポインタであり、そのポインタの先にはHが格納され、メモリ上には続いてelloが格納されている。そのアドレスを二つ増やしたメモリに格納されている値はlとなる。*("Enjoy!" + 3)は、*("welcome" + 2)と同様の理由でoとなる。

# 2-9
#### 実行結果
&x = 0x104b7c000, &y = 0x104b7c004
str1 = 0x104b7c000, str2 = 0x104b7c004
&str1 = 0x104b7c008, &str2 = 0x104b7c010
str1: Hi!
str2: Fine#

#### 理由
int型の変数x, yの格納されている値が一行目に表示される。str1, str2はx, yのアドレスをchar型のポインタにキャストしているので、str1, str2はポインタであり、x, yのアドレスが文字列として格納されているメモリのアドレスが格納されている。にgyほうめでは

# 2-10
実行結果
```
sizeof(double) = 8, sizeof(struct bar) = 24
&bar = 0x1027a8000, &bar.a = 0x1027a8000, &bar.b = 0x1027a8004, &bar.c = 0x1027a8008, &bar.d = 0x1027a8010
```
#### 理由
アライメント規約により、int型は4の倍数のアドレスから、double型は、8の倍数のアドレスからメモリが割り当てられる。したがって、パディングが生じ、実行結果のようになる。

# 2-11
memcpyは、第一引数のポインタの指すメモリの内容と第二引数のポインタの指すメモリの内容を比較する。パディングが初期化されている保証がないので、構造体のメンバの中身が同じでもパディングの中身が異なり、0を返さない可能性があるから。

# 2-12
-fpack-structオプションをつけてコンパイルすると実行結果は次のようになった。
```
sizeof(double) = 8, sizeof(struct bar) = 14
&bar = 0x102ccc000, &bar.a = 0x102ccc000, &bar.b = 0x102ccc001, &bar.c = 0x102ccc005, &bar.d = 0x102ccc006
```
この結果を見ると、メンバbはint型であるが４の倍数ではない0x102ccc001がアドレスとなっている。したがって、パディングを行わないというオプションであると考えられる。













